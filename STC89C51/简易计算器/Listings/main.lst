C51 COMPILER V9.60.7.0   MAIN                                                              07/01/2025 22:26:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.l
                    -st) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include <stdlib.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          
   6          // 数码管位选控制 
   7          sbit LSA = P2^2;  
   8          sbit LSB = P2^3;  
   9          sbit LSC = P2^4;  
  10          
  11          // 全局变量定义
  12          long num1 = 0, num2 = 0, result = 0;  // 输入数和结果
  13          long current_value = 0;     // 当前输入值
  14          uchar input_count = 0;      // 输入位数计数
  15          uchar operation = 0;        // 运算符 (0:无, 1:+, 2:-, 3:*, 4:/)
  16          uchar clear_flag = 0;       // 清除显示标志
  17          uchar display_data[8];      // 数码管显示缓冲区
  18          
  19          // 数码管段码表 
  20          uchar code seg_table[] = {
  21              0x3F, 0x06, 0x5B, 0x4F, 0x66, // 0-4
  22              0x6D, 0x7D, 0x07, 0x7F, 0x6F, // 5-9
  23              0x77, 0x7C, 0x39, 0x5E, 0x79, // A, b, C, d, E
  24              0x71, 0x08, 0x40, 0x00        // F, _, - , 空
  25          };
  26          
  27          // 按键映射表 (
  28          uchar code key_table[4][4] = {
  29              {15,  0, 14, 13},   //第四行: C(15), 0, =(14), +(13)
  30              { 1,  2,  3, 10},   // 第三行: 1, 2, 3, -(10)
  31              { 4,  5,  6, 11},   // 第二行: 4, 5, 6, *(11)
  32              { 7,  8,  9, 12}    // 第一行: 7, 8, 9, /(12)
  33          };
  34          
  35          // 毫秒级延时函数
  36          void delay_ms(uint ms) {
  37   1          uint i, j;
  38   1          for(i = 0; i < ms; i++)
  39   1              for(j = 0; j < 114; j++);  
  40   1      }
  41          
  42          // 数码管显示函数
  43          void display() {
  44   1          uchar i;
  45   1          for(i = 0; i < 8; i++) {
  46   2              // 位选控制 
  47   2              switch(i)
  48   2                      {
  49   3                              case 0: LSC=1;LSB=1;LSA=1;break;
  50   3                              case 1: LSC=1;LSB=1;LSA=0;break;
  51   3                              case 2: LSC=1;LSB=0;LSA=1;break;
  52   3                              case 3: LSC=1;LSB=0;LSA=0;break;
  53   3                              case 4: LSC=0;LSB=1;LSA=1;break;
  54   3                              case 5: LSC=0;LSB=1;LSA=0;break;
C51 COMPILER V9.60.7.0   MAIN                                                              07/01/2025 22:26:08 PAGE 2   

  55   3                              case 6: LSC=0;LSB=0;LSA=1;break;
  56   3                              case 7: LSC=0;LSB=0;LSA=0;break;
  57   3                      }
  58   2              // 段选输出
  59   2              P0 = seg_table[display_data[i]];
  60   2              delay_ms(1);         // 显示延时
  61   2              P0 = 0x00;           // 消隐 
  62   2          }
  63   1      }
  64          
  65          // 获取按键值 
  66          uchar get_key() {
  67   1          uchar row, col;
  68   1          uchar key_value = 0xFF;
  69   1          uchar temp;
  70   1          
  71   1          // 扫描4行 (从物理底部行开始扫描)
  72   1          for(row = 0; row < 4; row++) {
  73   2              // 激活当前行(输出低电平)
  74   2              P1 = 0xFF & ~(0x10 << (3 - row));  // 行选择: 依次激活物理行
  75   2              // 读取列状态
  76   2              temp = P1 & 0x0F;     // 取低4位(列状态)
  77   2              // 检查是否有列被拉低
  78   2              if(temp != 0x0F) {
  79   3                  // 消抖
  80   3                  delay_ms(10);
  81   3                  temp = P1 & 0x0F;
  82   3                  if(temp != 0x0F) {
  83   4                      // 确定被按下的列
  84   4                      switch(temp) {
  85   5                          case 0x07: col = 0; break; // P1.3=0 (0111)
  86   5                          case 0x0B: col = 1; break; // P1.2=0 (1011)
  87   5                          case 0x0D: col = 2; break; // P1.1=0 (1101)
  88   5                          case 0x0E: col = 3; break; // P1.0=0 (1110)
  89   5                          default: break;
  90   5                      }
  91   4                      // 获取按键值 (物理行号需要反转)
  92   4                      key_value = key_table[3 - row][col];
  93   4                      // 等待按键释放
  94   4                      while((P1 & 0x0F) != 0x0F);
  95   4                      return key_value;
  96   4                  }
  97   3              }
  98   2          }
  99   1          return 0xFF;
 100   1      }
 101          
 102          // 更新显示缓冲区 
 103          void update_display() {
 104   1          long temp = current_value; // 始终显示当前值
 105   1          uchar i;
 106   1              uchar pos = 7; // 从最右边的数码管开始
 107   1          uchar digits[8];
 108   1          uchar num_digits = 0;
 109   1          uchar negative = 0;
 110   1          uchar start_pos = 0;  
 111   1          // 清除显示
 112   1          if(clear_flag) {
 113   2              for(i = 0; i < 8; i++) 
 114   2                  display_data[i] = 16; // 16对应空显示
 115   2              clear_flag = 0;          // 清除标志复位
 116   2              return;
C51 COMPILER V9.60.7.0   MAIN                                                              07/01/2025 22:26:08 PAGE 3   

 117   2          }
 118   1          
 119   1          // 检查是否为负数
 120   1          if(temp < 0) {
 121   2              negative = 1;
 122   2              temp = -temp;
 123   2          }
 124   1          // 分离数字 (低位在前，高位在后)
 125   1          if(temp == 0) {
 126   2              // 输入0时显示0
 127   2              digits[0] = 0;
 128   2              num_digits = 1;
 129   2          } else {
 130   2              // 分离出所有数字（个位在前）
 131   2              while(temp > 0 && num_digits < 8) {
 132   3                  digits[num_digits] = temp % 10;  // 先分离个位
 133   3                  temp /= 10;
 134   3                  num_digits++;
 135   3              }
 136   2          }
 137   1          // 1. 初始化所有显示为空
 138   1          for(i = 0; i < 8; i++) {
 139   2              display_data[i] = 16;
 140   2          }
 141   1          // 3. 放置数字（从个位开始，向左放置更高位）
 142   1          for(i = 0; i < num_digits; i++) {
 143   2              if(pos < 8) { // 确保不会越界
 144   3                  display_data[pos] = digits[i];
 145   3                  pos--;
 146   3              }
 147   2          }
 148   1          // 4. 放置负号（如果有空间）
 149   1          if(negative && pos >= 0) {
 150   2              display_data[pos] = 17; // 负号
 151   2          }
 152   1      }
 153          
 154          // 主函数 - 程序入口
 155          void main() {
 156   1          uchar key;
 157   1          uchar i;
 158   1          // 初始化显示 - 全空
 159   1          for(i = 0; i < 8; i++) 
 160   1              display_data[i] = 16;
 161   1          while(1) {
 162   2              key = get_key();  // 获取按键
 163   2              if(key != 0xFF) { // 有按键按下
 164   3                  // 数字键处理
 165   3                  if(key <= 9) { 
 166   4                      if(input_count < 8) { // 最多8位
 167   5                          // 计算新值
 168   5                          current_value = current_value * 10 + key;
 169   5                          input_count++;
 170   5                          // 更新显示
 171   5                          update_display();
 172   5                      }
 173   4                  } 
 174   3                  // 清除键 (C)
 175   3                  else if(key == 15) { 
 176   4                      num1 = 0;
 177   4                      num2 = 0;
 178   4                      result = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              07/01/2025 22:26:08 PAGE 4   

 179   4                      current_value = 0;
 180   4                      operation = 0;
 181   4                      input_count = 0;
 182   4                      clear_flag = 1; // 设置清除标志
 183   4                      update_display();
 184   4                  } 
 185   3                  // 等于键 (=)
 186   3                  else if(key == 14) { 
 187   4                      if(operation) { // 有运算符时才计算
 188   5                          num2 = current_value; // 保存第二个操作数
 189   5                          // 执行运算
 190   5                          switch(operation) {
 191   6                              case 1: result = num1 + num2; break; // 加
 192   6                              case 2: result = num1 - num2; break; // 减
 193   6                              case 3: result = num1 * num2; break; // 乘
 194   6                              case 4: 
 195   6                                  if(num2 != 0) result = num1 / num2; // 除
 196   6                                  else result = 0; // 除0处理
 197   6                                  break;
 198   6                          }
 199   5                          // 显示结果
 200   5                          current_value = result;
 201   5                          operation = 0;   // 运算符复位
 202   5                          num1 = result;   // 结果作为下一次的第一个操作数
 203   5                          input_count = 0; // 输入计数复位
 204   5                          // 更新显示
 205   5                          update_display();
 206   5                      }
 207   4                  } 
 208   3                  // 运算符键 (+, -, *, /)
 209   3                  else if(key >= 10 && key <= 13) { 
 210   4                      // 保存第一个操作数
 211   4                      if(operation == 0) {
 212   5                          num1 = current_value;
 213   5                      }
 214   4                      // 设置运算符
 215   4                      if(key == 13) operation = 1;      // +
 216   4                      else if(key == 10) operation = 2; // -
 217   4                      else if(key == 11) operation = 3; // *
 218   4                      else if(key == 12) operation = 4; // /
 219   4                      // 准备输入新操作数
 220   4                      current_value = 0;
 221   4                      input_count = 0;
 222   4                      // 清除显示
 223   4                      clear_flag = 1;
 224   4                      update_display();
 225   4                      clear_flag = 0;
 226   4                  }
 227   3              }
 228   2              display(); // 刷新数码管显示
 229   2          }
 230   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    965    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              07/01/2025 22:26:08 PAGE 5   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
